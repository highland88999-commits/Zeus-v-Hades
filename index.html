<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>HADES vs ZEUS â€¢ NEON SOUL RACE</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=VT323&display=swap" rel="stylesheet" />
  <style>
    :root {
      --neon-cyan: #00f0ff;
      --neon-magenta: #ff0066;
      --neon-gold: #ffe700;
      --neon-green: #39ff14;
      --neon-purple: #c300ff;
    }

    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      margin:0;
      overflow:hidden;
      background:#000;
      font-family:'Orbitron',sans-serif;
      color:var(--neon-cyan);
      height:100dvh;
      touch-action:none;
    }

    #stars {
      position:fixed;
      inset:0;
      background:radial-gradient(ellipse at bottom, #0b001f 0%,#000 100%);
      z-index:-2;
      pointer-events:none;
    }
    .star {
      position:absolute;
      background:white;
      border-radius:50%;
      box-shadow:0 0 8px rgba(255,255,255,0.8);
      animation:twinkle 5s infinite alternate;
    }
    @keyframes twinkle { 0%,100%{opacity:0.35} 50%{opacity:0.95} }

    #gameContainer {
      position:relative;
      width:100dvw;
      height:100dvh;
      overflow:hidden;
    }
    #gameCanvas {
      display:block;
      width:100%;
      height:100%;
      image-rendering:crisp-edges;
      touch-action:none;
    }

    /* Overlays */
    #landingOverlay,
    #difficultyOverlay,
    #startVideoOverlay,
    #gameOverOverlay {
      position:fixed;
      inset:0;
      z-index:100;
      background:rgba(0,0,0,0.92);
      backdrop-filter:blur(10px);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      color:var(--neon-cyan);
      font-size:clamp(1.4rem,5vw,2.8rem);
      text-align:center;
      cursor:pointer;
    }
    .hidden { display:none !important; }

    #countdown {
      font-size:clamp(8rem,25vw,16rem);
      font-weight:900;
      text-shadow:0 0 50px var(--neon-gold),0 0 100px var(--neon-cyan);
      margin-bottom:1.5rem;
      animation:pulse 1s infinite alternate;
    }
    @keyframes pulse { to { transform:scale(1.08); } }

    .neon-title {
      font-size:clamp(4rem,14vw,9rem);
      font-weight:900;
      letter-spacing:0.1em;
      background:linear-gradient(90deg,var(--neon-magenta),var(--neon-cyan),var(--neon-magenta));
      -webkit-background-clip:text;
      background-clip:text;
      -webkit-text-fill-color:transparent;
      text-shadow:0 0 40px var(--neon-magenta);
      animation:glitch 4s infinite;
    }
    @keyframes glitch {
      0%,100%{text-shadow:5px 0 var(--neon-magenta),-5px 0 var(--neon-cyan)}
      20%{text-shadow:-5px 0 var(--neon-magenta),5px 0 var(--neon-cyan)}
      40%{text-shadow:5px 0 var(--neon-cyan),-5px 0 var(--neon-magenta)}
      60%{text-shadow:-7px 0 var(--neon-magenta),7px 0 var(--neon-cyan)}
      80%{text-shadow:7px 0 var(--neon-cyan),-7px 0 var(--neon-magenta)}
    }

    #hud {
      position:fixed;
      top:0; left:0; right:0;
      padding:clamp(0.8rem,2vw,1.2rem) 2rem;
      display:flex;
      justify-content:space-between;
      background:rgba(0,0,0,0.7);
      backdrop-filter:blur(14px);
      z-index:30;
      font-size:clamp(1.2rem,3.5vw,1.9rem);
      pointer-events:none;
    }
    .score-box {
      background:rgba(10,10,30,0.75);
      padding:0.6rem 1.4rem;
      border-radius:1rem;
      border:2px solid;
      box-shadow:0 0 25px;
    }
    #playerScore { border-color:var(--neon-cyan); color:var(--neon-cyan); left:0; position:absolute; }
    #oppScore   { border-color:var(--neon-magenta); color:var(--neon-magenta); right:0; position:absolute; }
    #timer      { color:var(--neon-gold); font-weight:900; margin:auto; }

    /* Scanlines */
    body::before {
      content:'';
      position:fixed;
      inset:0;
      background:repeating-linear-gradient(to bottom,transparent 0,transparent 2px,rgba(0,0,0,0.32) 2px,rgba(0,0,0,0.32) 4px);
      pointer-events:none;
      z-index:999;
      opacity:0.55;
    }

    .neon-btn {
      background: linear-gradient(90deg, var(--neon-magenta), var(--neon-cyan));
      border: none;
      color: #000;
      font-family: inherit;
      font-weight: 700;
      letter-spacing: 0.05em;
      border-radius: 0.5rem;
      cursor: pointer;
      box-shadow: 0 0 20px var(--neon-magenta);
      animation: glitch 4s infinite;
      padding:1.2rem 3rem;
      font-size:clamp(1.4rem,4.5vw,2.2rem);
    }

    #difficultyOverlay {
      gap: 2rem;
    }

    .difficulty-btn {
      background: linear-gradient(90deg, var(--neon-green), var(--neon-purple));
      border: none;
      color: #000;
      font-family: inherit;
      font-weight: 700;
      letter-spacing: 0.05em;
      border-radius: 0.5rem;
      cursor: pointer;
      box-shadow: 0 0 20px var(--neon-green);
      animation: glitch 4s infinite;
      padding:0.8rem 2rem;
      font-size:clamp(1.2rem,4vw,2rem);
      margin: 1rem;
    }

    #zoomIndicator {
      position: fixed;
      bottom: 50%;
      left: 50%;
      transform: translate(-50%, 50%);
      z-index: 50;
      background: rgba(0,0,0,0.8);
      padding: 1rem 2rem;
      border-radius: 1rem;
      color: var(--neon-gold);
      font-size: 1.5rem;
      opacity: 0;
      transition: opacity 1s;
    }

    #radar {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 150px;
      height: 150px;
      background: rgba(0,0,0,0.3);
      border: 2px solid var(--neon-cyan);
      border-radius: 50%;
      overflow: hidden;
      z-index: 40;
      pointer-events: none;
    }

    #radarCanvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>

<div id="stars"></div>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>

  <!-- Landing Video -->
  <div id="landingOverlay">
    <video id="landingVideo" playsinline>
      <source src="https://www.dropbox.com/scl/fi/9mz9tl38fbz6f0e1tj30y/Make_it_epic._H-3.mp4?rlkey=4rk9zotckomw7ugprgdp8lro1&st=ejqlz1hl&raw=1" type="video/mp4" />
    </video>
    <div class="neon-title">CLICK TO ENTER THE VOID</div>
  </div>

  <!-- Difficulty Selection -->
  <div id="difficultyOverlay" class="hidden">
    <div class="neon-title">CHOOSE YOUR PATH</div>
    <button class="difficulty-btn" onclick="selectDifficulty('easy')">RECRUIT</button>
    <button class="difficulty-btn" onclick="selectDifficulty('medium')">ENLIGHTENED</button>
    <button class="difficulty-btn" onclick="selectDifficulty('hard')">MASTER</button>
  </div>

  <!-- Start Video + 3s Countdown -->
  <div id="startVideoOverlay" class="hidden">
    <video id="startVideo" playsinline>
      <source src="https://www.dropbox.com/scl/fi/4r1tkm2o12essg59t5iyk/Make_it_epic._H-2.mp4?rlkey=rcv76t3n3vyouwkp96a16mkyi&st=07jeqjbn&raw=1" type="video/mp4" />
    </video>
    <div id="countdown">3</div>
  </div>

  <!-- HUD -->
  <div id="hud" class="hidden">
    <div id="playerScore" class="score-box">YOU: <span id="pScore">0</span></div>
    <div id="timer">2:00</div>
    <div id="oppScore" class="score-box">OPP: <span id="oScore">0</span></div>
  </div>

  <!-- Game Over -->
  <div id="gameOverOverlay" class="hidden">
    <div class="neon-title" style="font-size:clamp(3rem,10vw,6rem);">RACE TERMINATED</div>
    <p id="goResult" style="font-size:clamp(1.8rem,5vw,3rem); margin:1.5rem 0;"></p>
    <p id="goScore" style="font-size:clamp(1.4rem,4vw,2.5rem); color:var(--neon-gold);"></p>
    <button onclick="location.reload()" class="neon-btn" style="padding:0.8rem 2rem; font-size:clamp(1rem,3vw,1.8rem);">RE-ENTER NEON REALM</button>
  </div>

  <!-- Zoom Indicator -->
  <div id="zoomIndicator" class="hidden">Pinch or Scroll to Zoom</div>

  <!-- Radar -->
  <div id="radar" class="hidden">
    <canvas id="radarCanvas"></canvas>
  </div>
</div>

<iframe id="bgm" width="0" height="0" frameborder="0" allow="autoplay"></iframe>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIG
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WORLD_W = 5200;
const WORLD_H = 3900;
const GAME_TIME = 120;
const POSEIDON_INTERVAL = 30;
const BASE_SOULS = 90;
const RADAR_SIZE = 150;

const DIFFICULTY = {
  easy:   { aiSpeed:4.3, redChance:0.14, powerChance:0.07, speedChance:0.10, purpleChance:0.02, portalChance:0.03, playerBoost:2 },
  medium: { aiSpeed:5.7, redChance:0.26, powerChance:0.05, speedChance:0.08, purpleChance:0.015, portalChance:0.025, playerBoost:1.5 },
  hard:   { aiSpeed:7.2, redChance:0.38, powerChance:0.04, speedChance:0.06, purpleChance:0.01, portalChance:0.02, playerBoost:1 }
};

let difficulty = 'medium'; // default
let playerChar = 'Zeus'; // default

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let canvas, ctx, radarCanvas, radarCtx;
let player, opponent, souls = [], particles = [], stars = [], portals = [];
let camX = 0, camY = 0, zoom = 1, targetZoom = 1;
let timeLeft = GAME_TIME;
let poseidonTimer = POSEIDON_INTERVAL;
let isRunning = false;
let floodProgress = 0;
let isFlooding = false;
let isDragging = false;
let pointerWorldX = 0, pointerWorldY = 0;
let viewW, viewH;
let isMobile = /Mobi|Android/i.test(navigator.userAgent);
let showZoomIndicator = true;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DOM
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const landingOverlay = document.getElementById('landingOverlay');
const landingVideo = document.getElementById('landingVideo');
const difficultyOverlay = document.getElementById('difficultyOverlay');
const startOverlay = document.getElementById('startVideoOverlay');
const startVideo = document.getElementById('startVideo');
const countdownEl = document.getElementById('countdown');
const hud = document.getElementById('hud');
const pScoreEl = document.getElementById('pScore');
const oScoreEl = document.getElementById('oScore');
const timerEl = document.getElementById('timer');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const goResult = document.getElementById('goResult');
const goScore = document.getElementById('goScore');
const bgm = document.getElementById('bgm');
const zoomIndicator = document.getElementById('zoomIndicator');
const radar = document.getElementById('radar');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MUSIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const musicTracks = [
  "https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1&mute=0&controls=0&loop=1&playlist=dQw4w9WgXcQ",
  "https://www.youtube.com/embed/jfKfPfyJRdk?autoplay=1&mute=0&controls=0&loop=1&playlist=jfKfPfyJRdk",
  "https://www.youtube.com/embed/9bZkp7q19f0?autoplay=1&mute=0&controls=0&loop=1&playlist=9bZkp7q19f0",
];

function playRandomMusic() {
  const track = musicTracks[Math.floor(Math.random() * musicTracks.length)];
  bgm.src = track;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HELPERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

function isInView(x, y, r = 0) {
  return x + r > camX && x - r < camX + viewW && y + r > camY && y - r < camY + viewH;
}

function debounce(func, wait) {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}

function getHighValueSouls() {
  return souls.filter(s => s.value >= 250);
}

function getRandomHighValueSoul() {
  const highValues = getHighValueSouls();
  if (highValues.length > 0) {
    return highValues[Math.floor(Math.random() * highValues.length)];
  }
  return null;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INIT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function init() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  radarCanvas = document.getElementById('radarCanvas');
  radarCtx = radarCanvas.getContext('2d');
  resize();
  window.addEventListener('resize', debounce(resize, 200));
  createBgStars();
  createWorldStars();

  // Sequential videos
  landingOverlay.addEventListener('click', () => {
    if (landingVideo.paused) {
      landingVideo.play().catch(() => {});
    } else {
      landingOverlay.classList.add('hidden');
      landingVideo.pause(); // stop landing audio
      difficultyOverlay.classList.remove('hidden');
    }
  });

  setupControls();
}

function createBgStars() {
  const starsDiv = document.getElementById('stars');
  const numBgStars = isMobile ? 150 : 300;
  for (let i = 0; i < numBgStars; i++) {
    const star = document.createElement('div');
    star.className = 'star';
    star.style.width = star.style.height = (Math.random() * 1.5 + 0.5) + 'px';
    star.style.left = (Math.random() * 100) + '%';
    star.style.top = (Math.random() * 100) + '%';
    star.style.animationDelay = (Math.random() * 5) + 's';
    starsDiv.appendChild(star);
  }
}

function createWorldStars() {
  const numWorldStars = isMobile ? 350 : 700;
  for (let i = 0; i < numWorldStars; i++) {
    stars.push({
      x: Math.random() * WORLD_W,
      y: Math.random() * WORLD_H,
      size: Math.random() * 2.2 + 0.5,
      phase: Math.random() * Math.PI * 2
    });
  }
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  radarCanvas.width = RADAR_SIZE;
  radarCanvas.height = RADAR_SIZE;
  targetZoom = Math.min(canvas.width / WORLD_W, canvas.height / WORLD_H); // default full view
}

function selectDifficulty(level) {
  difficulty = level;
  difficultyOverlay.classList.add('hidden');
  startOverlay.classList.remove('hidden');
  startVideo.play().catch(() => {});
  startCountdown();
}

function startCountdown() {
  let cd = 3;
  countdownEl.textContent = cd;
  const interval = setInterval(() => {
    cd--;
    countdownEl.textContent = cd;
    if (cd <= 0) {
      clearInterval(interval);
      startOverlay.classList.add('hidden');
      startVideo.pause(); // stop start video audio
      hud.classList.remove('hidden');
      radar.classList.remove('hidden');
      resetGame();
      isRunning = true;
      requestAnimationFrame(gameLoop);
      setInterval(gameTimer, 1000);
      playRandomMusic();
      showZoomIndicatorFunc();
    }
  }, 1000);
}

function showZoomIndicatorFunc() {
  zoomIndicator.classList.remove('hidden');
  zoomIndicator.style.opacity = 1;
  setTimeout(() => {
    zoomIndicator.style.opacity = 0;
  }, 3000);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RESET
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetGame() {
  timeLeft = GAME_TIME;
  poseidonTimer = POSEIDON_INTERVAL;
  floodProgress = 0;
  isFlooding = false;

  const cfg = DIFFICULTY[difficulty];

  player = {
    x: WORLD_W / 2,
    y: WORLD_H / 2,
    baseSpeed: cfg.aiSpeed * cfg.playerBoost,
    speed: cfg.aiSpeed * cfg.playerBoost,
    speedMult: 1,
    speedEnd: 0,
    size: 34,
    color: playerChar === 'Zeus' ? '#00f0ff' : '#ff0066',
    symbol: playerChar === 'Zeus' ? 'âš¡' : 'ðŸ’€',
    score: 0
  };

  opponent = {
    x: WORLD_W / 2 + (Math.random() - 0.5) * 1400,
    y: WORLD_H / 2 + (Math.random() - 0.5) * 1400,
    baseSpeed: cfg.aiSpeed,
    speed: cfg.aiSpeed,
    speedMult: 1,
    speedEnd: 0,
    size: 34,
    color: playerChar === 'Zeus' ? '#ff0066' : '#00f0ff',
    symbol: playerChar === 'Zeus' ? 'ðŸ’€' : 'âš¡',
    score: 0,
    target: null
  };

  souls = [];
  particles = [];
  portals = [];
  generateSouls(BASE_SOULS);
  generatePortals(5); // e.g., 5 portals
  updateHUD();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOUL GENERATOR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateSouls(count) {
  const cfg = DIFFICULTY[difficulty];
  for (let i = 0; i < count; i++) {
    const r = Math.random();
    let type = 'blue', val = 100, col = '#88ddff', rad = 12;
    if (r < cfg.redChance) { type = 'red'; val = -25; col = '#ff4444'; rad = 13; }
    else if (r < cfg.redChance + cfg.powerChance) { type = 'power'; val = 250; col = '#ffd700'; rad = 18; }
    else if (r < cfg.redChance + cfg.powerChance + cfg.speedChance) { type = 'speed'; val = 0; col = '#00aaff'; rad = 15; }
    else if (r < cfg.redChance + cfg.powerChance + cfg.speedChance + cfg.purpleChance) { type = 'purple'; val = 1000; col = '#c300ff'; rad = 22; }

    souls.push({
      x: Math.random() * WORLD_W,
      y: Math.random() * WORLD_H,
      radius: rad,
      color: col,
      value: val,
      type,
      pulse: Math.random() * Math.PI * 2
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PORTAL GENERATOR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generatePortals(count) {
  for (let i = 0; i < count; i++) {
    portals.push({
      x: Math.random() * WORLD_W,
      y: Math.random() * WORLD_H,
      radius: 25,
      color: '#00ff00'
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TIMER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameTimer() {
  if (!isRunning) return;
  timeLeft--;
  poseidonTimer--;
  if (poseidonTimer <= 0) {
    isFlooding = true;
    floodProgress = 0;
    poseidonTimer = POSEIDON_INTERVAL;
  }
  if (timeLeft <= 0) endGame();
  updateHUD();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop() {
  if (!isRunning) return;

  updateGame();
  drawGame();
  drawRadar();

  requestAnimationFrame(gameLoop);
}

function updateGame() {
  const now = Date.now() / 1000;

  player.speedMult = (player.speedEnd > now) ? 2 : 1;
  player.speed = player.baseSpeed * player.speedMult;

  opponent.speedMult = (opponent.speedEnd > now) ? 2 : 1;
  opponent.speed = opponent.baseSpeed * opponent.speedMult;

  if (isDragging) {
    const dx = pointerWorldX - player.x;
    const dy = pointerWorldY - player.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > 0) {  // Avoid division by zero
      const moveSpeed = player.speed; // Always move at full speed in the direction
      player.x += (dx / d) * moveSpeed;
      player.y += (dy / d) * moveSpeed;
    }
    player.x = Math.max(player.size, Math.min(WORLD_W - player.size, player.x));
    player.y = Math.max(player.size, Math.min(WORLD_H - player.size, player.y));
  }

  updateOpponent();
  checkCollisions();
  checkPortalCollisions();
  updateParticles();
  updateCamera();

  if (isFlooding) {
    floodProgress += 0.02;
    if (floodProgress >= 1) {
      souls = [];
      portals = [];
      isFlooding = false;
      generateSouls(BASE_SOULS + 25);
      generatePortals(5);
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AI
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateOpponent() {
  if (!opponent.target || dist(opponent, opponent.target) < opponent.size + opponent.target.radius) {
    opponent.target = closestSoul(opponent);
  }

  if (opponent.target) {
    const dx = opponent.target.x - opponent.x;
    const dy = opponent.target.y - opponent.y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > opponent.speed) {
      opponent.x += (dx / d) * opponent.speed;
      opponent.y += (dy / d) * opponent.speed;
    } else {
      opponent.x = opponent.target.x;
      opponent.y = opponent.target.y;
    }
  }

  opponent.x = Math.max(opponent.size, Math.min(WORLD_W - opponent.size, opponent.x));
  opponent.y = Math.max(opponent.size, Math.min(WORLD_H - opponent.size, opponent.y));
}

function closestSoul(entity) {
  let minDist = Infinity;
  let closest = null;
  souls.forEach(s => {
    const d = dist(entity, s);
    if (d < minDist) {
      minDist = d;
      closest = s;
    }
  });
  return closest;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COLLISIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkCollisions() {
  souls = souls.filter(s => {
    if (dist(player, s) < player.size + s.radius) {
      collectSoul(player, s);
      return false;
    }
    if (dist(opponent, s) < opponent.size + s.radius) {
      collectSoul(opponent, s);
      return false;
    }
    return true;
  });
}

function collectSoul(entity, soul) {
  if (soul.type === 'speed') {
    entity.speedEnd = Date.now() / 1000 + 8;
  } else {
    entity.score += soul.value;
  }
  createParticles(soul.x, soul.y, soul.color);
}

function checkPortalCollisions() {
  portals.forEach(p => {
    if (dist(player, p) < player.size + p.radius) {
      teleportEntity(player);
    }
    if (dist(opponent, p) < opponent.size + p.radius) {
      teleportEntity(opponent);
    }
  });
}

function teleportEntity(entity) {
  const targetSoul = getRandomHighValueSoul();
  if (targetSoul) {
    entity.x = targetSoul.x;
    entity.y = targetSoul.y;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PARTICLES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createParticles(x, y, color) {
  const numParticles = isMobile ? 10 : 20;
  for (let i = 0; i < numParticles; i++) {
    particles.push({
      x,
      y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8,
      life: Math.random() * 30 + 20,
      color,
      size: Math.random() * 4 + 2
    });
  }
}

function updateParticles() {
  particles = particles.filter(p => {
    p.life--;
    p.x += p.vx;
    p.y += p.vy;
    return p.life > 0;
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CAMERA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCamera() {
  zoom += (targetZoom - zoom) * 0.05;

  viewW = canvas.width / zoom;
  viewH = canvas.height / zoom;

  camX = player.x - viewW / 2;
  camY = player.y - viewH / 2;

  camX = Math.max(0, Math.min(WORLD_W - viewW, camX));
  camY = Math.max(0, Math.min(WORLD_H - viewH, camY));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DRAW
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawGame() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(-camX * zoom, -camY * zoom);
  ctx.scale(zoom, zoom);

  drawWorldStars();
  souls.forEach(drawSoul);
  portals.forEach(drawPortal);
  drawEntity(player);
  drawEntity(opponent);
  particles.forEach(drawParticle);
  drawIndicators();

  ctx.restore();

  if (isFlooding) drawFlood();
}

function drawWorldStars() {
  stars.forEach(s => {
    if (isInView(s.x, s.y, s.size)) {
      s.phase += 0.02;
      const bright = Math.sin(s.phase) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(255,255,255,${bright})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
      ctx.fill();
    }
  });
}

function drawSoul(s) {
  if (isInView(s.x, s.y, s.radius)) {
    s.pulse += 0.08;
    const pulse = Math.sin(s.pulse) * 3 + s.radius;

    ctx.beginPath();
    ctx.arc(s.x, s.y, pulse, 0, Math.PI * 2);

    ctx.shadowColor = s.color;
    ctx.shadowBlur = 20;
    ctx.fillStyle = s.color;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawPortal(p) {
  if (isInView(p.x, p.y, p.radius)) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 3;
    ctx.stroke();
  }
}

function drawEntity(e) {
  if (isInView(e.x, e.y, e.size)) {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fillStyle = e.color;
    ctx.fill();

    ctx.font = '40px serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(e.symbol, e.x, e.y);
  }
}

function drawParticle(p) {
  if (isInView(p.x, p.y, p.size)) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.globalAlpha = p.life / 50;
    ctx.fillStyle = p.color;
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawFlood() {
  ctx.globalAlpha = floodProgress * 0.7;
  ctx.fillStyle = 'rgba(0,50,200,1)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.globalAlpha = 1;
}

function drawIndicators() {
  const highValues = getHighValueSouls();
  highValues.forEach(s => {
    if (!isInView(s.x, s.y, s.radius)) {
      const dx = s.x - player.x;
      const dy = s.y - player.y;
      const angle = Math.atan2(dy, dx);
      const arrowX = player.x + Math.cos(angle) * 100;
      const arrowY = player.y + Math.sin(angle) * 100;

      ctx.beginPath();
      ctx.moveTo(arrowX, arrowY);
      ctx.lineTo(arrowX - Math.cos(angle + Math.PI / 6) * 20, arrowY - Math.sin(angle + Math.PI / 6) * 20);
      ctx.moveTo(arrowX, arrowY);
      ctx.lineTo(arrowX - Math.cos(angle - Math.PI / 6) * 20, arrowY - Math.sin(angle - Math.PI / 6) * 20);
      ctx.strokeStyle = '#ffe700';
      ctx.lineWidth = 5;
      ctx.stroke();
    }
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RADAR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRadar() {
  radarCtx.clearRect(0, 0, RADAR_SIZE, RADAR_SIZE);
  radarCtx.fillStyle = 'rgba(0,0,0,0.5)';
  radarCtx.fillRect(0, 0, RADAR_SIZE, RADAR_SIZE);

  const scaleX = RADAR_SIZE / WORLD_W;
  const scaleY = RADAR_SIZE / WORLD_H;

  // Player
  radarCtx.fillStyle = player.color;
  radarCtx.beginPath();
  radarCtx.arc(player.x * scaleX, player.y * scaleY, 3, 0, Math.PI * 2);
  radarCtx.fill();

  // Opponent
  radarCtx.fillStyle = opponent.color;
  radarCtx.beginPath();
  radarCtx.arc(opponent.x * scaleX, opponent.y * scaleY, 3, 0, Math.PI * 2);
  radarCtx.fill();

  // Souls
  souls.forEach(s => {
    radarCtx.fillStyle = s.color;
    radarCtx.beginPath();
    radarCtx.arc(s.x * scaleX, s.y * scaleY, 1, 0, Math.PI * 2);
    radarCtx.fill();
  });

  // Portals
  portals.forEach(p => {
    radarCtx.fillStyle = p.color;
    radarCtx.beginPath();
    radarCtx.arc(p.x * scaleX, p.y * scaleY, 2, 0, Math.PI * 2);
    radarCtx.fill();
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONTROLS (mouse/touch drag)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupControls() {
  canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    pointerWorldX = camX + (e.clientX - rect.left) / zoom;
    pointerWorldY = camY + (e.clientY - rect.top) / zoom;
    const d = dist({x: pointerWorldX, y: pointerWorldY}, player);
    if (d < player.size * 10) { // Larger threshold for easier starting
      isDragging = true;
    }
  });

  canvas.addEventListener('pointermove', e => {
    if (!isRunning || !isDragging) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    pointerWorldX = camX + (e.clientX - rect.left) / zoom;
    pointerWorldY = camY + (e.clientY - rect.top) / zoom;
  });

  canvas.addEventListener('pointerup', () => {
    isDragging = false;
  });

  // Zoom
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY < 0 ? 0.1 : -0.1;
    targetZoom = Math.max(0.6, Math.min(2.5, targetZoom + delta));
  }, { passive: false });

  let initialDist = 0;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      initialDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
      const delta = (dist - initialDist) / 400;
      targetZoom = Math.max(0.6, Math.min(2.5, targetZoom + delta));
      initialDist = dist;
    }
  }, { passive: false });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HUD & END GAME
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHUD() {
  pScoreEl.textContent = player.score;
  oScoreEl.textContent = opponent.score;

  const min = Math.floor(timeLeft / 60);
  const sec = (timeLeft % 60).toString().padStart(2, '0');
  timerEl.textContent = `\( {min}: \){sec}`;
}

function endGame() {
  isRunning = false;

  const result = player.score > opponent.score ? 'VICTORY' :
                 player.score < opponent.score ? 'DEFEAT' : 'STALEMATE';

  goResult.innerHTML = `<span style="color:\( {result==='VICTORY' ? 'var(--neon-green)' : 'var(--neon-magenta)'}"> \){result}</span>`;
  goScore.textContent = `YOU ${player.score} â€¢ OPP ${opponent.score}`;

  gameOverOverlay.classList.remove('hidden');
  hud.classList.add('hidden');
  radar.classList.add('hidden');
}

init();
</script>
</body>
</html>
