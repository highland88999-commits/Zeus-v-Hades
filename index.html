<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>HADES vs ZEUS â€¢ NEON SOUL RACE</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&family=VT323&display=swap" rel="stylesheet" />
  <style>
    :root {
      --neon-cyan: #00f0ff;
      --neon-magenta: #ff0066;
      --neon-gold: #ffe700;
      --neon-green: #39ff14;
      --neon-purple: #c300ff;
    }

    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      margin:0;
      overflow:hidden;
      background:#000;
      font-family:'Orbitron',sans-serif;
      color:var(--neon-cyan);
      height:100dvh;
      touch-action:none;
    }

    #stars {
      position:fixed;
      inset:0;
      background:radial-gradient(ellipse at bottom, #0b001f 0%,#000 100%);
      z-index:-2;
      pointer-events:none;
    }
    .star {
      position:absolute;
      background:white;
      border-radius:50%;
      box-shadow:0 0 8px rgba(255,255,255,0.8);
      animation:twinkle 5s infinite alternate;
    }
    @keyframes twinkle { 0%,100%{opacity:0.35} 50%{opacity:0.95} }

    #gameContainer {
      position:relative;
      width:100dvw;
      height:100dvh;
      overflow:hidden;
    }
    #gameCanvas {
      display:block;
      width:100%;
      height:100%;
      image-rendering:crisp-edges;
      touch-action:none;
    }

    /* Overlays */
    #landingOverlay,
    #startVideoOverlay,
    #gameOverOverlay {
      position:fixed;
      inset:0;
      z-index:100;
      background:rgba(0,0,0,0.92);
      backdrop-filter:blur(10px);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      color:var(--neon-cyan);
      font-size:clamp(1.4rem,5vw,2.8rem);
      text-align:center;
      cursor:pointer;
    }
    .hidden { display:none !important; }

    #countdown {
      font-size:clamp(8rem,25vw,16rem);
      font-weight:900;
      text-shadow:0 0 50px var(--neon-gold),0 0 100px var(--neon-cyan);
      margin-bottom:1.5rem;
      animation:pulse 1s infinite alternate;
    }
    @keyframes pulse { to { transform:scale(1.08); } }

    .neon-title {
      font-size:clamp(4rem,14vw,9rem);
      font-weight:900;
      letter-spacing:0.1em;
      background:linear-gradient(90deg,var(--neon-magenta),var(--neon-cyan),var(--neon-magenta));
      -webkit-background-clip:text;
      background-clip:text;
      -webkit-text-fill-color:transparent;
      text-shadow:0 0 40px var(--neon-magenta);
      animation:glitch 4s infinite;
    }
    @keyframes glitch {
      0%,100%{text-shadow:5px 0 var(--neon-magenta),-5px 0 var(--neon-cyan)}
      20%{text-shadow:-5px 0 var(--neon-magenta),5px 0 var(--neon-cyan)}
      40%{text-shadow:5px 0 var(--neon-cyan),-5px 0 var(--neon-magenta)}
      60%{text-shadow:-7px 0 var(--neon-magenta),7px 0 var(--neon-cyan)}
      80%{text-shadow:7px 0 var(--neon-cyan),-7px 0 var(--neon-magenta)}
    }

    #hud {
      position:fixed;
      top:0; left:0; right:0;
      padding:clamp(0.8rem,2vw,1.2rem) 2rem;
      display:flex;
      justify-content:space-between;
      background:rgba(0,0,0,0.7);
      backdrop-filter:blur(14px);
      z-index:30;
      font-size:clamp(1.2rem,3.5vw,1.9rem);
      pointer-events:none;
    }
    .score-box {
      background:rgba(10,10,30,0.75);
      padding:0.6rem 1.4rem;
      border-radius:1rem;
      border:2px solid;
      box-shadow:0 0 25px;
    }
    #playerScore { border-color:var(--neon-cyan); color:var(--neon-cyan); }
    #oppScore   { border-color:var(--neon-magenta); color:var(--neon-magenta); }
    #timer      { color:var(--neon-gold); font-weight:900; }

    #joystick {
      position:fixed;
      bottom:clamp(50px,10vh,90px);
      right:clamp(50px,10vw,90px);
      width:clamp(160px,32vw,260px);
      height:clamp(160px,32vw,260px);
      z-index:60;
      opacity:0;
      transition:opacity 0.7s;
      pointer-events:none;
    }
    #joystick.visible { opacity:1; pointer-events:auto; }
    #joyBase {
      position:absolute;
      inset:0;
      border-radius:50%;
      background:rgba(255,255,255,0.07);
      border:4px solid rgba(0,240,255,0.55);
      box-shadow:inset 0 0 40px rgba(0,240,255,0.35);
    }
    #joyKnob {
      position:absolute;
      width:38%;
      height:38%;
      border-radius:50%;
      background:radial-gradient(circle at 30% 30%, white, var(--neon-cyan));
      box-shadow:0 0 40px var(--neon-cyan), inset 0 0 16px white;
      transform:translate(-50%,-50%);
      left:50%; top:50%;
      transition:transform 0.07s;
    }

    /* Scanlines */
    body::before {
      content:'';
      position:fixed;
      inset:0;
      background:repeating-linear-gradient(to bottom,transparent 0,transparent 2px,rgba(0,0,0,0.32) 2px,rgba(0,0,0,0.32) 4px);
      pointer-events:none;
      z-index:999;
      opacity:0.55;
    }
  </style>
</head>
<body>

<div id="stars"></div>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>

  <!-- Landing Video -->
  <div id="landingOverlay">
    <video id="landingVideo" playsinline>
      <source src="https://www.dropbox.com/scl/fi/9mz9tl38fbz6f0e1tj30y/Make_it_epic._H-3.mp4?rlkey=4rk9zotckomw7ugprgdp8lro1&st=ejqlz1hl&raw=1" type="video/mp4" />
    </video>
    <div class="neon-title">CLICK TO ENTER THE VOID</div>
  </div>

  <!-- Start Video + 3s Countdown -->
  <div id="startVideoOverlay" class="hidden">
    <video id="startVideo" playsinline>
      <source src="https://www.dropbox.com/scl/fi/4r1tkm2o12essg59t5iyk/Make_it_epic._H-2.mp4?rlkey=rcv76t3n3vyouwkp96a16mkyi&st=07jeqjbn&raw=1" type="video/mp4" />
    </video>
    <div id="countdown">3</div>
  </div>

  <!-- HUD -->
  <div id="hud" class="hidden">
    <div id="playerScore" class="score-box">YOU: <span id="pScore">0</span></div>
    <div id="timer">2:00</div>
    <div id="oppScore" class="score-box">OPP: <span id="oScore">0</span></div>
  </div>

  <!-- Joystick -->
  <div id="joystick">
    <div id="joyBase">
      <div id="joyKnob"></div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOverOverlay" class="hidden">
    <div class="neon-title">RACE TERMINATED</div>
    <p id="goResult" style="font-size:clamp(2.2rem,7vw,4.5rem); margin:2.5rem 0;"></p>
    <p id="goScore" style="font-size:clamp(1.8rem,5.5vw,3.2rem); color:var(--neon-gold);"></p>
    <button onclick="location.reload()" style="margin-top:4rem; padding:1.2rem 3rem; font-size:clamp(1.4rem,4.5vw,2.2rem);" class="neon-btn">RE-ENTER NEON REALM</button>
  </div>
</div>

<audio id="bgm" loop></audio>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIG
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const WORLD_W = 5200;
const WORLD_H = 3900;
const GAME_TIME = 120;
const POSEIDON_INTERVAL = 30;
const BASE_SOULS = 90;

const DIFFICULTY = {
  easy:   { aiSpeed:4.3, redChance:0.14, powerChance:0.07, speedChance:0.10 },
  medium: { aiSpeed:5.7, redChance:0.26, powerChance:0.05, speedChance:0.08 },
  hard:   { aiSpeed:7.2, redChance:0.38, powerChance:0.04, speedChance:0.06 }
};

let difficulty = 'medium'; // default, can add selection
let playerChar = 'Zeus'; // default, can add selection

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let canvas, ctx;
let player, opponent, souls = [], particles = [], stars = [];
let camX = 0, camY = 0, zoom = 1, targetZoom = 1;
let timeLeft = GAME_TIME;
let poseidonTimer = POSEIDON_INTERVAL;
let isRunning = false;
let joystickActive = false;
let lastTouchId = null;
let floodProgress = 0;
let isFlooding = false;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // DOM
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const landingOverlay   = document.getElementById('landingOverlay');
const landingVideo     = document.getElementById('landingVideo');
const startOverlay     = document.getElementById('startVideoOverlay');
const startVideo       = document.getElementById('startVideo');
const countdownEl      = document.getElementById('countdown');
const hud              = document.getElementById('hud');
const joystick         = document.getElementById('joystick');
const joyKnob          = document.getElementById('joyKnob');
const pScoreEl         = document.getElementById('pScore');
const oScoreEl         = document.getElementById('oScore');
const timerEl          = document.getElementById('timer');
const gameOverOverlay  = document.getElementById('gameOverOverlay');
const goResult         = document.getElementById('goResult');
const goScore          = document.getElementById('goScore');
const bgm              = document.getElementById('bgm');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // MUSIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const musicTracks = [
  "https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1&mute=0&controls=0&loop=1",
  "https://www.youtube.com/embed/jfKfPfyJRdk?autoplay=1&mute=0&controls=0&loop=1",
  "https://www.youtube.com/embed/9bZkp7q19f0?autoplay=1&mute=0&controls=0&loop=1",
];

function playRandomMusic() {
  const track = musicTracks[Math.floor(Math.random() * musicTracks.length)];
  bgm.src = track;
  bgm.volume = 0.5;
  bgm.play().catch(e => console.log("Autoplay blocked:", e));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // INIT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function init() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);
  createStars();

  // Landing flow
  landingOverlay.addEventListener('click', () => {
    if (landingVideo.paused) {
      landingVideo.play().catch(() => {});
    } else {
      landingOverlay.classList.add('hidden');
      startOverlay.classList.remove('hidden');
      startVideo.play().catch(() => {});
      startCountdown();
    }
  });

  setupControls();
}

function createStars() {
  for (let i = 0; i < 700; i++) {
    stars.push({
      x: Math.random() * WORLD_W,
      y: Math.random() * WORLD_H,
      size: Math.random() * 2.2 + 0.5,
      phase: Math.random() * Math.PI * 2
    });
  }
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function startCountdown() {
  let cd = 3;
  countdownEl.textContent = cd;
  const interval = setInterval(() => {
    cd--;
    countdownEl.textContent = cd;
    if (cd <= 0) {
      clearInterval(interval);
      startOverlay.classList.add('hidden');
      hud.classList.remove('hidden');
      joystick.classList.add('visible');
      resetGame();
      isRunning = true;
      requestAnimationFrame(gameLoop);
      setInterval(gameTimer, 1000);
      playRandomMusic();
    }
  }, 1000);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // RESET GAME
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetGame() {
  timeLeft = GAME_TIME;
  poseidonTimer = POSEIDON_INTERVAL;
  floodProgress = 0;
  isFlooding = false;

  player = {
    x: WORLD_W / 2,
    y: WORLD_H / 2,
    baseSpeed: 6,
    speedMult: 1,
    speedEnd: 0,
    size: 34,
    color: playerChar === 'Zeus' ? '#00f0ff' : '#ff0066',
    symbol: playerChar === 'Zeus' ? 'âš¡' : 'ðŸ’€',
    score: 0
  };

  opponent = {
    x: WORLD_W / 2 + (Math.random() - 0.5) * 1400,
    y: WORLD_H / 2 + (Math.random() - 0.5) * 1400,
    speed: DIFFICULTY[difficulty].aiSpeed,
    size: 34,
    color: playerChar === 'Zeus' ? '#ff0066' : '#00f0ff',
    symbol: playerChar === 'Zeus' ? 'ðŸ’€' : 'âš¡',
    score: 0,
    target: null
  };

  souls = [];
  particles = [];
  spawnSouls(BASE_SOULS);
  updateHUD();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SPAWN SOULS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnSouls(count) {
  const cfg = DIFFICULTY[difficulty];
  for (let i = 0; i < count; i++) {
    const r = Math.random();
    let type = 'blue', val = 100, col = '#88ddff', rad = 12;
    if (r < cfg.redChance) { type = 'red'; val = -25; col = '#ff4444'; rad = 13; }
    else if (r < cfg.redChance + cfg.powerChance) { type = 'power'; val = 250; col = '#ffd700'; rad = 18; }
    else if (r < cfg.redChance + cfg.powerChance + cfg.speedChance) { type = 'speed'; val = 0; col = '#00aaff'; rad = 15; }

    souls.push({
      x: Math.random() * WORLD_W,
      y: Math.random() * WORLD_H,
      radius: rad,
      color: col,
      value: val,
      type,
      pulse: Math.random() * Math.PI * 2
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // GAME TIMER & POSEIDON
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameTimer() {
  if (!isRunning) return;
  timeLeft--;
  poseidonTimer--;
  if (poseidonTimer <= 0) {
    isFlooding = true;
    floodProgress = 0;
    poseidonTimer = POSEIDON_INTERVAL;
  }
  if (timeLeft <= 0) endGame();
  updateHUD();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAIN LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop() {
  if (!isRunning) return;

  updateGame();
  drawGame();

  requestAnimationFrame(gameLoop);
}

function updateGame() {
  if (player.speedEnd > Date.now() / 1000) {
    player.speedMult = 2;
  } else {
    player.speedMult = 1;
  }

  updateOpponent();
  checkCollisions();
  updateParticles();
  updateCamera();

  // Flood mechanic
  if (isFlooding) {
    floodProgress += 0.02;
    if (floodProgress >= 1) {
      souls = [];
      isFlooding = false;
      spawnSouls(BASE_SOULS + 25);
    }
  }
}

function updateOpponent() {
  const cfg = DIFFICULTY[difficulty];
  if (!opponent.target || !souls.includes(opponent.target)) {
    if (souls.length === 0) return;
    opponent.target = souls.reduce((best, s) => {
      const d1 = Math.hypot(opponent.x - best.x, opponent.y - best.y);
      const d2 = Math.hypot(opponent.x - s.x, opponent.y - s.y);
      return d2 < d1 ? s : best;
    }, souls[0]);
  }

  const dx = opponent.target.x - opponent.x;
  const dy = opponent.target.y - opponent.y;
  const dist = Math.hypot(dx, dy);

  if (dist > 8) {
    opponent.x += (dx / dist) * cfg.aiSpeed;
    opponent.y += (dy / dist) * cfg.aiSpeed;
  } else {
    const idx = souls.indexOf(opponent.target);
    if (idx !== -1) {
      opponent.score += souls[idx].value;
      addParticles(souls[idx].x, souls[idx].y, souls[idx].color, 28);
      souls.splice(idx, 1);
      opponent.target = null;
    }
  }

  opponent.x = Math.max(20, Math.min(WORLD_W - 20, opponent.x));
  opponent.y = Math.max(20, Math.min(WORLD_H - 20, opponent.y));
}

function checkCollisions() {
  for (let i = souls.length - 1; i >= 0; i--) {
    const s = souls[i];
    const d = Math.hypot(player.x - s.x, player.y - s.y);
    if (d < player.size + s.radius + 12) {
      player.score += s.value;
      addParticles(s.x, s.y, s.color, s.type === 'power' ? 50 : s.type === 'speed' ? 35 : 25);
      if (s.type === 'speed') player.speedEnd = Date.now() / 1000 + 5;
      souls.splice(i, 1);
      if (navigator.vibrate) navigator.vibrate(s.value > 0 ? 60 : 120);
    }
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.018;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function addParticles(x, y, color, count = 30) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = Math.random() * 10 + 4;
    particles.push({
      x, y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd,
      life: 1,
      color,
      size: Math.random() * 6 + 2
    });
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // CAMERA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCamera() {
  camX = player.x - canvas.width / (2 * zoom);
  camY = player.y - canvas.height / (2 * zoom);
  camX = Math.max(0, Math.min(WORLD_W - canvas.width / zoom, camX));
  camY = Math.max(0, Math.min(WORLD_H - canvas.height / zoom, camY));

  zoom += (targetZoom - zoom) * 0.1;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DRAW
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background gradient
  const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height));
  if (playerChar === 'Zeus') {
    grad.addColorStop(0, '#0a001f');
    grad.addColorStop(0.5, '#1a0033');
    grad.addColorStop(1, '#000011');
  } else {
    grad.addColorStop(0, '#001122');
    grad.addColorStop(0.5, '#002233');
    grad.addColorStop(1, '#000811');
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(-camX * zoom, -camY * zoom);
  ctx.scale(zoom, zoom);

  // Stars
  stars.forEach(s => {
    const alpha = 0.4 + Math.sin(s.phase + performance.now() * 0.001) * 0.4;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Souls (orbs)
  souls.forEach(s => {
    const r = s.radius + Math.sin(s.pulse += 0.15) * 4;
    ctx.shadowColor = s.color;
    ctx.shadowBlur = 30;
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 15;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(s.x, s.y, r * 0.35, 0, Math.PI * 2);
    ctx.fill();
  });

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 20 * p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Players (orbs with symbols)
  [player, opponent].forEach(p => {
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 35;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 15;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * 0.4, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.fillStyle = 'white';
    ctx.font = `${p.size * 1.8}px Orbitron, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.symbol, p.x, p.y);
  });

  // Poseidon flood water cover
  if (isFlooding) {
    ctx.globalAlpha = 0.65 + Math.sin(floodProgress * Math.PI) * 0.35;
    ctx.fillStyle = 'rgba(0, 100, 255, 0.5)';
    ctx.fillRect(0, 0, WORLD_W * floodProgress, WORLD_H);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function updateHUD() {
  pScoreEl.textContent = player.score;
  oScoreEl.textContent = opponent.score;

  const min = Math.floor(timeLeft / 60);
  const sec = (timeLeft % 60).toString().padStart(2, '0');
  timerEl.textContent = `${min}:${sec}`;
}

function endGame() {
  isRunning = false;
  joystick.classList.remove('visible');

  const result = player.score > opponent.score ? 'VICTORY' :
                 player.score < opponent.score ? 'DEFEAT' : 'STALEMATE';

  goResult.innerHTML = `<span style="color:${result==='VICTORY' ? 'var(--neon-green)' : 'var(--neon-magenta)'}">${result}</span>`;
  goScore.textContent = `YOU ${player.score} â€¢ OPP ${opponent.score}`;

  gameOverOverlay.classList.remove('hidden');
  hud.classList.add('hidden');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INPUT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupControls() {
  let joyRect, centerX, centerY;

  function updateJoystick(e) {
    if (!joystickActive) return;
    e.preventDefault();

    const tx = e.touches ? e.touches[0].clientX : e.clientX;
    const ty = e.touches ? e.touches[0].clientY : e.clientY;

    let dx = tx - joyRect.left - centerX;
    let dy = ty - joyRect.top - centerY;
    const len = Math.hypot(dx, dy);

    if (len > centerX * 0.85) {
      dx *= (centerX * 0.85) / len;
      dy *= (centerX * 0.85) / len;
    }

    joyKnob.style.left = `${centerX + dx}px`;
    joyKnob.style.top  = `${centerY + dy}px`;

    player.dx = (dx / centerX) * 8 * player.speedMult;
    player.dy = (dy / centerY) * 8 * player.speedMult;
  }

  joyKnob.addEventListener('pointerdown', e => {
    e.preventDefault();
    joystickActive = true;
    joyRect = joystick.getBoundingClientRect();
    centerX = joyRect.width / 2;
    centerY = joyRect.height / 2;
    updateJoystick(e);

    const onMove = ev => updateJoystick(ev);
    const onUp = () => {
      joystickActive = false;
      joyKnob.style.left = '50%';
      joyKnob.style.top = '50%';
      player.dx = player.dy = 0;
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
    };

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
  });

  // Direct touch follow fallback
  canvas.addEventListener('pointermove', e => {
    if (joystickActive) return;
    if (e.pointerType === 'mouse' && e.buttons !== 1) return;

    const rect = canvas.getBoundingClientRect();
    player.x = (e.clientX - rect.left) * (WORLD_W / rect.width) + camX;
    player.y = (e.clientY - rect.top) * (WORLD_H / rect.height) + camY;

    player.x = Math.max(20, Math.min(WORLD_W - 20, player.x));
    player.y = Math.max(20, Math.min(WORLD_H - 20, player.y));
  });

  // Pinch zoom
  let initialDist = 0;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      initialDist = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const dist = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
      const delta = (dist - initialDist) / 400;
      targetZoom = Math.max(0.6, Math.min(2.5, targetZoom + delta));
      initialDist = dist;
    }
  }, { passive: false });

  // Wheel zoom
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.2 : 0.2;
    targetZoom = Math.max(0.6, Math.min(2.5, targetZoom + delta));
  }, { passive: false });
}

init();
</script>
</body>
</html>
